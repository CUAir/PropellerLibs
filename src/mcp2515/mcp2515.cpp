//
// automatically generated by spin2cpp v1.05 on Sun Dec 18 23:15:39 2016
// \\vmware-host\Shared Folders\Documents\spin2cpp\spin2cpp.exe mcp2515.spin
//

#include <stdlib.h>
#include <propeller.h>
#include "mcp2515.h"
//#include "simpletools.h"

#ifdef __GNUC__
#define INLINE__ static inline
#define Yield__() __asm__ volatile( "" ::: "memory" )
#define PostEffect__(X, Y) __extension__({ int32_t tmp__ = (X); (X) = (Y); tmp__; })
#else
#define INLINE__ static
static int32_t tmp__;
#define PostEffect__(X, Y) (tmp__ = (X), (X) = (Y), tmp__)
#define Yield__()
#endif

INLINE__ int32_t Rotl__(uint32_t a, uint32_t b) { return (a<<b) | (a>>(32-b)); }
INLINE__ int32_t Rotr__(uint32_t a, uint32_t b) { return (a>>b) | (a<<(32-b)); }
INLINE__ int32_t Shr__(uint32_t a, uint32_t b) { return (a>>b); }

mcp2515::mcp2515(uint8_t p_cs, uint8_t p_sck, uint8_t p_mosi, uint8_t p_miso) {
    cs = p_cs;
    sck = p_sck;
    mosi = p_mosi;
    miso = p_miso;
    lock = locknew();
}

void mcp2515::init(uint16_t baud, uint8_t mode) {
    Start(cs, sck, mosi, miso, lock); //start the can driver
    Reset(); // reset can driver
    waitcnt(CLKFREQ/1000 + CNT);
    Set_mode(mode_config);
    Set_baud(baud); // set can bit rate (kbps)
    Write(Txb0ctrl, 0); //clear any TX pending (from all 3 buffers)
    Write(Txb1ctrl, 0);
    Write(Txb2ctrl, 0);
    Write(Txrtsctrl, 0); // set rx RTS to inputs
    Write(Caninte, 0); // celar interrupts
    Write(Canintf, 0);    // disable RXnBF pins
    Set_mode(mode);
}

void mcp2515::set_rx0_filters(int16_t mask, int16_t f0, int16_t f1) {
    Set_mode(mode_config);
    Set_rxb0_filters(mask, f0, f1);
    Set_mode(mode);
}

void mcp2515::set_rx1_filters(int16_t mask, int16_t f2, int16_t f3, int16_t f4, int16_t f5) {
    Set_mode(mode_config);
    Set_rxb1_filters(mask, f2, f3, f4, f5);
    Set_mode(mode);
}

bool mcp2515::tx(can_frame f) {
    if (Tx_buf_ready(0)) {
      Tx_stdframe(0, f.id, f.len, (int32_t)f.buf, Pri_high);
      return true;
    }

    if (Tx_buf_ready(1)) {
      Tx_stdframe(1, f.id, f.len, (int32_t)f.buf, Pri_high);
      return true;
    }

    if (Tx_buf_ready(2)) {
      Tx_stdframe(2, f.id, f.len, (int32_t)f.buf, Pri_high);
      return true;
    }

    // no buffers available
    return false;
}

mcp2515::can_frame mcp2515::rx(int8_t b) {

    mcp2515::can_frame f = {0};
    // read from first non-empty buffer
    if (b == -1) {
      uint8_t t = Rx_stdframe(0, (int32_t)(&(f.id)), (int32_t)(&(f.len)), (int32_t)(f.buf));
      if (t == Frame_data) {
          Clear_rx_intf(0);
          return f;
      }

      t = Rx_stdframe(1, (int32_t)(&(f.id)), (int32_t)(&(f.len)), (int32_t)(f.buf));
      if (t == Frame_data) {
          Clear_rx_intf(1);
          return f;
      }
      // read from buffer 0 or 1 as given by b
    } else if (b == 0 || b == 1) {
      uint8_t t = Rx_stdframe(b, (int32_t)(&(f.id)), (int32_t)(&(f.len)), (int32_t)(f.buf));
      if (t == Frame_data) {
          Clear_rx_intf(b);
          return f;
      }
    }

    return f;
}


int32_t mcp2515::Start(int32_t Cspin, int32_t Sckpin, int32_t Mosipin, int32_t Misopin, int32_t Lock)
{
    int32_t _parm__0000[5];
    _parm__0000[0] = Cspin;
    _parm__0000[1] = Sckpin;
    _parm__0000[2] = Mosipin;
    _parm__0000[3] = Misopin;
    _parm__0000[4] = Lock;
    if (Inuse) {
      //Stop();
    }
    memmove( (void *)&Cs, (void *)&_parm__0000[0], 4*(5));
    if (Cs < 0) {
      Csmode = Pullup;
      Cs = (abs(Cs));
    } else {
      Csmode = Driven;
    }
    Csmode = Driven;
    Chip_select(0);
    OUTA &= ~(1<<Sck);
    DIRA |= (1<<Sck);
    OUTA &= ~(1<<Mosi);
    DIRA |= (1<<Mosi);
    DIRA &= ~(1<<Miso);
    Inuse = -1;
    return 0;
}

int32_t mcp2515::Stop(void)
{
    DIRA &= ~(1<<Cs);
    DIRA &= ~(1<<Sck);
    DIRA &= ~(1<<Mosi);
    Inuse = 0;
    return 0;
}

int32_t mcp2515::Set_mode(int32_t Mode)
{
    int32_t	Check;
    Bit_modify(Canctrl, mode_mask, Mode);
    return 0;
}

int32_t mcp2515::Get_mode(void)
{
    return (Read(Canstat) & 0xe0);
}

int32_t mcp2515::Set_baud(int32_t Kbps)
{
    int32_t	Mode;
    if (Kbps == 10) {
      Write(Cnf1, 31);
      Write(Cnf2, 255);
      Write(Cnf3, 7);
      return 10;
    } else if (Kbps == 20) {
      Write(Cnf1, 15);
      Write(Cnf2, 255);
      Write(Cnf3, 7);
      return 20;
    } else if (Kbps == 50) {
      Write(Cnf1, 7);
      Write(Cnf2, 236);
      Write(Cnf3, 7);
      return 50;
    } else if (Kbps == 100) {
      Write(Cnf1, 3);
      Write(Cnf2, 236);
      Write(Cnf3, 7);
      return 100;
    } else if (Kbps == 125) {
      Write(Cnf1, 3);
      Write(Cnf2, 218);
      Write(Cnf3, 7);
      return 125;
    } else if (Kbps == 250) {
      Write(Cnf1, 1);
      Write(Cnf2, 228);
      Write(Cnf3, 4);
      return 250;
    } else if (Kbps == 500) {
      Write(Cnf1, 0);
      Write(Cnf2, 228);
      Write(Cnf3, 4);
      return 500;
    } else if (Kbps == 800) {
      Write(Cnf1, 0);
      Write(Cnf2, 210);
      Write(Cnf3, 2);
      return 800;
    } else if (Kbps == 1000) {
      Write(Cnf1, 0);
      Write(Cnf2, 201);
      Write(Cnf3, 2);
      return 1000;
    } else if (1) {
      return (-1);
    }
}

int32_t mcp2515::Tx_buf_ready(int32_t Buf)
{
    int32_t	Ctrl;
    if ((Buf >= 0) && (Buf <= 2)) {
      Ctrl = Read((Txb0ctrl + Buf));
      return -((Ctrl & 0x8) == 0);
    } else {
      return 0;
    }
}

int32_t mcp2515::Tx_stdframe(int32_t Buf, int32_t Stdid, int32_t Dlc, int32_t Pntr, int32_t Priority)
{
    if (Buf == 0) {
      Write(Txb0sidh, (Shr__(Stdid, 3)));
      Write(Txb0sidl, (Stdid << 5));
      Write(Txb0eid8, 0);
      Write(Txb0eid0, 0);
      Write(Txb0dlc, Dlc);
      if ((Dlc >= 1) && (Dlc <= 8)) {
          Write_block(Txb0d0, Pntr, Dlc);
      }
      Write(Txb0ctrl, (0x8 | (Priority & 0x3)));
    } else if (Buf == 1) {
      Write(Txb1sidh, (Shr__(Stdid, 3)));
      Write(Txb1sidl, (Stdid << 5));
      Write(Txb1eid8, 0);
      Write(Txb1eid0, 0);
      Write(Txb1dlc, Dlc);
      if ((Dlc >= 1) && (Dlc <= 8)) {
          Write_block(Txb1d0, Pntr, Dlc);
      }
      Write(Txb1ctrl, (0x8 | (Priority & 0x3)));
    } else if (Buf == 2) {
      Write(Txb2sidh, (Shr__(Stdid, 3)));
      Write(Txb2sidl, (Stdid << 5));
      Write(Txb2eid8, 0);
      Write(Txb2eid0, 0);
      Write(Txb2dlc, Dlc);
      if ((Dlc >= 1) && (Dlc <= 8)) {
          Write_block(Txb2d0, Pntr, Dlc);
      }
      Write(Txb2ctrl, (0x8 | (Priority & 0x3)));
    }
    return 0;
}

int32_t mcp2515::Set_rxb0_filters(int32_t Mask0, int32_t Filter0, int32_t Filter1)
{
    Write(Rxm0sidh, (Shr__(Mask0, 3)));
    Write(Rxm0sidl, (Mask0 << 5));
    Write(Rxf0sidh, (Shr__(Filter0, 3)));
    Write(Rxf0sidl, (Filter0 << 5));
    Write(Rxf1sidh, (Shr__(Filter1, 3)));
    Write(Rxf1sidl, (Filter1 << 5));
    return 0;
}

int32_t mcp2515::Set_rxb1_filters(int32_t Mask1, int32_t Filter2, int32_t Filter3, int32_t Filter4, int32_t Filter5)
{
    Write(Rxm1sidh, (Shr__(Mask1, 3)));
    Write(Rxm1sidl, (Mask1 << 5));
    Write(Rxf2sidh, (Shr__(Filter2, 3)));
    Write(Rxf2sidl, (Filter2 << 5));
    Write(Rxf3sidh, (Shr__(Filter3, 3)));
    Write(Rxf3sidl, (Filter3 << 5));
    Write(Rxf4sidh, (Shr__(Filter4, 3)));
    Write(Rxf4sidl, (Filter4 << 5));
    Write(Rxf5sidh, (Shr__(Filter5, 3)));
    Write(Rxf5sidl, (Filter5 << 5));
    return 0;
}

int32_t mcp2515::Rx_stdframe(int32_t Buf, int32_t Msgpntr, int32_t Dlcpntr, int32_t Datapntr)
{
    if (Buf == 0) {
      if (Rd_status() & 0x1) {
          ((uint16_t *)Msgpntr)[0] = Get_rx_stdid(0);
          ((uint8_t *)Dlcpntr)[0] = Get_rx_dlc(0);
          memset( (void *)Datapntr, 0, 1*(8));
          if (((uint8_t *)Dlcpntr)[0] <= 8) {
            Read_block(Rxb0d0, Datapntr, ((uint8_t *)Dlcpntr)[0]);
            return Frame_data;
          } else {
            ((uint8_t *)Dlcpntr)[0] = (((uint8_t *)Dlcpntr)[0] & 0xf);
            return Frame_remote;
          }
      }
    } else if (Buf == 1) {
      if (Rd_status() & 0x2) {
          ((uint16_t *)Msgpntr)[0] = Get_rx_stdid(1);
          ((uint8_t *)Dlcpntr)[0] = Get_rx_dlc(1);
          memset( (void *)Datapntr, 0, 1*(8));
          if (((uint8_t *)Dlcpntr)[0] <= 8) {
            Read_block(Rxb1d0, Datapntr, ((uint8_t *)Dlcpntr)[0]);
            return Frame_data;
          } else {
            ((uint8_t *)Dlcpntr)[0] = (((uint8_t *)Dlcpntr)[0] & 0xf);
            return Frame_remote;
          }
      }
    }
    return Frame_none;
}

int32_t mcp2515::Get_rx_stdid(int32_t Buf)
{
    if (Buf == 0) {
      return (((Read(Rxb0sidh) << 3) | (Shr__(Read(Rxb0sidl), 5))) & 0x7ff);
    } else if (Buf == 1) {
      return (((Read(Rxb1sidh) << 3) | (Shr__(Read(Rxb1sidl), 5))) & 0x7ff);
    } else if (1) {
      return (-1);
    }
}

int32_t mcp2515::Get_rx_dlc(int32_t Buf)
{
    if (Buf == 0) {
      return Read(Rxb0dlc);
    } else if (Buf == 1) {
      return Read(Rxb1dlc);
    } else if (1) {
      return (-1);
    }
}

int32_t mcp2515::Clear_rx_intf(int32_t Buf)
{
    if (Buf == 0) {
      Bit_modify(Canintf, 1, 0);
      return 0;
    } else if (Buf == 1) {
      Bit_modify(Canintf, 2, 0);
      return 1;
    } else if (1) {
      return (-1);
    }
}

int32_t mcp2515::Reset(void)
{
    Lock_buss(-1);
    Chip_select(-1);
    Spi_readwrite(Cmd_reset);
    Chip_select(0);
    Lock_buss(0);
    return 0;
}

int32_t mcp2515::Read(int32_t Addr)
{
    int32_t	Dataout;
    Lock_buss(-1);
    Chip_select(-1);
    Spi_readwrite(Cmd_read);
    Spi_readwrite(Addr);
    Dataout = Spi_readwrite(0);
    Chip_select(0);
    Lock_buss(0);
    return Dataout;
}

int32_t mcp2515::Read_block(int32_t Addr, int32_t Pntr, int32_t N)
{
    int32_t result = 0;
    if (N <= 0) {
      return result;
    }
    Lock_buss(-1);
    Chip_select(-1);
    Spi_readwrite(Cmd_read);
    Spi_readwrite(Addr);
    {
      int32_t _idx__0001;
      int32_t _limit__0002 = N;
      for(_idx__0001 = 1; _idx__0001 <= _limit__0002; (_idx__0001 = (_idx__0001 + 1))) {
          ((uint8_t *)(Pntr++))[0] = Spi_readwrite(0);
      }
    }
    Chip_select(0);
    Lock_buss(0);
    return result;
}

int32_t mcp2515::Read_rxbuf(int32_t Bufsel)
{
    int32_t	Dataout;
    Lock_buss(-1);
    Chip_select(-1);
    Spi_readwrite((0x90 | (Bufsel << 1)));
    Dataout = Spi_readwrite(0);
    Chip_select(0);
    Lock_buss(-1);
    return Dataout;
}

int32_t mcp2515::Write(int32_t Addr, int32_t Value)
{
    Lock_buss(-1);
    Chip_select(-1);
    Spi_readwrite(Cmd_write);
    Spi_readwrite(Addr);
    Spi_readwrite(Value);
    Chip_select(0);
    Lock_buss(0);
    return 0;
}

int32_t mcp2515::Write_block(int32_t Addr, int32_t Pntr, int32_t N)
{
    Lock_buss(-1);
    Chip_select(-1);
    Spi_readwrite(Cmd_write);
    Spi_readwrite(Addr);
    {
      int32_t _idx__0003;
      int32_t _limit__0004 = N;
      for(_idx__0003 = 1; _idx__0003 <= _limit__0004; (_idx__0003 = (_idx__0003 + 1))) {
          Spi_readwrite(((uint8_t *)(Pntr++))[0]);
      }
    }
    Chip_select(0);
    Lock_buss(0);
    return 0;
}

int32_t mcp2515::Load_txbuf(int32_t Datain, int32_t Bufsel)
{
    Lock_buss(-1);
    Chip_select(-1);
    Spi_readwrite((0x40 | (Bufsel & 0x7)));
    Spi_readwrite(Datain);
    Chip_select(0);
    Lock_buss(0);
    return 0;
}

int32_t mcp2515::Rts(int32_t Buf)
{
    Lock_buss(-1);
    Chip_select(-1);
    Spi_readwrite((0x80 | (Buf & 0x7)));
    Chip_select(0);
    Lock_buss(0);
    return 0;
}

int32_t mcp2515::Rd_status(void)
{
    int32_t	Statusbits;
    Lock_buss(-1);
    Chip_select(-1);
    Spi_readwrite(Cmd_rd_status);
    Statusbits = Spi_readwrite(0);
    Chip_select(0);
    Lock_buss(0);
    return Statusbits;
}

int32_t mcp2515::Rx_status(void)
{
    int32_t	Statusbits;
    Lock_buss(-1);
    Chip_select(-1);
    Spi_readwrite(Cmd_rx_status);
    Statusbits = Spi_readwrite(0);
    Chip_select(0);
    Lock_buss(0);
    return Statusbits;
}

int32_t mcp2515::Bit_modify(int32_t Addr, int32_t Mask, int32_t Datain)
{
    Lock_buss(-1);
    Chip_select(-1);
    Spi_readwrite(Cmd_bit_mod);
    Spi_readwrite(Addr);
    Spi_readwrite(Mask);
    Spi_readwrite(Datain);
    Chip_select(0);
    Lock_buss(0);
    return 0;
}

int32_t mcp2515::Lock_buss(int32_t State)
{
    int32_t result = 0;
    if (Lockid < 0) {
      return result;
    }
    if (State == 0) {
      if (Lockid >= 0) {
          lockclr(Lockid);
      }
    } else {
      if (Lockid >= 0) {
          while (!(!(lockset(Lockid)))) {
            Yield__();
          }
      }
    }
    return result;
}

int32_t mcp2515::Chip_select(int32_t State)
{
    if (Csmode == Driven) {
      if (State) {
          OUTA &= ~(1<<Cs);
          DIRA |= (1<<Cs);
      } else {
          OUTA |= (1<<Cs);
          DIRA |= (1<<Cs);
      }
    } else if (Csmode == Pullup) {
      if (State) {
          OUTA &= ~(1<<Cs);
          DIRA |= (1<<Cs);
      } else {
          DIRA &= ~(1<<Cs);
      }
    }
    return 0;
}

int32_t mcp2515::Spi_readwrite(int32_t Datain)
{
    int32_t	Dataout;
    Datain = (Datain << 0x18);
    {
      int32_t _idx__0005;
      for(_idx__0005 = 1; _idx__0005 <= 8; (_idx__0005 = (_idx__0005 + 1))) {
          OUTA = ((OUTA & (~(1 << Mosi))) | ((((Datain = (Rotl__(Datain, 1))) & 0x1) & 0x1) << Mosi));
          Dataout = ((Dataout << 1) | ((INA >> Miso) & 0x1));
          OUTA |= (1<<Sck);
          //waitcnt(CNT+200);
          OUTA &= ~(1<<Sck);
      }
    }
    return (Dataout & 0xff);
}

